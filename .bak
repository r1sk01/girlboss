    /*"debug": {
        description: "Enable or disable debug tools",
        arguments: ['true / false'],
        execute: async (envelope, message) => {
            const User = mongoose.model('User');
            try {
                await User.findOne({ userid: envelope.sourceUuid }).then((user) => {
                    if (!user.properties) {
                        user.properties = {};
                    }
                    if (user.properties.debug === undefined) {
                        user.properties.debug = false;
                    }
                    if (message === `${prefix}debug`) {
                        sendresponse(`Debug tools are currently ${user.properties.debug ? 'enabled' : 'disabled'} for you $MENTIONUSER.`, envelope, `${prefix}debug`, false);
                        return;
                    }
                    if (message === `${prefix}debug true`) {
                        user.properties.debug = true;
                        user.markModified('properties');
                        user.save();
                        setTimeout(() => {
                            sendresponse('Debug tools are now enabled for you $MENTIONUSER.', envelope, `${prefix}debug true`, false);
                        }, 100);
                        return;
                    }
                    if (message === `${prefix}debug false`) {
                        user.properties.debug = false;
                        user.markModified('properties');
                        user.save();
                        setTimeout(() => {
                            sendresponse('Debug tools are now disabled for you $MENTIONUSER.', envelope, `${prefix}debug false`, false);
                        }, 100);
                        return;
                    }
                    sendresponse('Invalid argument.\nUse "-debug true" or "-debug false" to enable or disable debug tools.', envelope, `${prefix}debug`, true);
                });
            } catch (err) {
                console.error(err);
                await sendresponse('Unable to connect to database, is MongoDB running?', envelope, `${prefix}debug`, true);
            }
        }
    },*/
    /*"yuri": {
        description: "Display a random image of furry girls kissing (unsafe removes filter)",
        arguments: ['unsafe'],
        execute: async (envelope, message) => {
            try {
                const username = 'tritiumbot';
                const apikey = 'E8c7UaU9bCAGqXZXkQb5W9Tg';
                let url = 'https://e621.net/posts/random.json?tags=young_female+kissing+female/female+rating:s';
                if (message === `${prefix}yuri unsafe`) {
                    url = 'https://e621.net/posts/random.json?tags=young_female+kissing+female/female+rating:e';
                }
                const botname = process.env.npm_package_name;
                const botversion = process.env.npm_package_version;
                const userAgent = `${botname}/${botversion} (nova@unleaked.me)`;
                let attempts = 0;
                while (attempts < 10) {
                    try {
                        const response = await axios.get(url, {
                            headers: {
                                'User-Agent': userAgent,
                                'Authorization': `Basic ${Buffer.from(`${username}:${apikey}`).toString('base64')}`
                            }
                        });
                        const imageUrl = response.data.post.file.url;
                        if (!imageUrl) {
                            attempts++;
                            continue;
                        }
                        if (response.data.post.file.size > 1000000) {
                            attempts++;
                            continue;
                        }
                        const image = await axios.get(imageUrl, {
                            responseType: 'arraybuffer'
                        });
                        const b64image = Buffer.from(image.data).toString('base64');
                        await sendresponse(null, envelope, `${prefix}yuri`, false, b64image, image.headers['content-type'], response.data.post.file.ext);
                        return;
                    } catch (err) {
                        throw new Error('Failed to fetch image from source. Please try again later.');
                    }
                }
                throw new Error('Failed to fetch image after 10 attempts. Please try again later.');
            } catch (err) {
                await sendresponse(err, envelope, `${prefix}yuri`, true);
            }
        }
    },
    "lemons": {
        description: "When life gives you lemons...",
        arguments: null,
        execute: async (envelope, message) => {
            try {
                await sendresponse(`When life gives you lemons?\nDon't make lemonade.\nMake life take the lemons back!\nGET MAD!\nI don't want your damn lemons!\nWhat am I supposed to do with these?\nDemand to see life's manager!\nMake life rue the day it thought it could give Cave Johnson lemons!\nDo you know who I am?\nI'm the man who's going to burn your house down!\nWith the lemons!\nI'm going to get my engineers to invent a combustible lemon that burns your house down!`, envelope, `${prefix}lemons`, false);
            } catch (err) {
                console.error(err);
            }
        }
    },
    "imbouttanut": {
        description: "Pretty dreamy ngl",
        arguments: null,
        execute: async (envelope, message) => {
            try {
                await sendresponse(null, envelope, `${prefix}imbouttanut`, false, null, null, null, './dreamybull.mp3');
            } catch (err) {
                await sendresponse('Somehow this command failed. Please try again later.', envelope, `${prefix}imbouttanut`, true);
            }
        }
    },
    "vnc": {
        description: "Show details for a random unsecured VNC server",
        arguments: null,
        execute: async (envelope, message) => {
            try {
                const botname = process.env.npm_package_name;
                const botversion = process.env.npm_package_version;
                const userAgent = `${botname}/${botversion} (nova@zeusteam.dev)`;
                const response = await axios.get('https://computernewb.com/vncresolver/api/v1/random?full=true', {
                    headers: {
                        'User-Agent': userAgent
                    }
                });
                const data = response.data;
                const vncimage = await axios.get(`https://computernewb.com/vncresolver/api/v1/screenshot/${data.id}`, {
                    responseType: 'arraybuffer',
                    headers: {
                        'User-Agent': userAgent
                    }
                });
                await sendresponse(`VNC Server Details:\nASN: ${data.asn}\nDesktop Name: ${data.desktop_name}\nLocation: ${data.geo_city}, ${data.geo_state}, ${data.geo_country}\nServer: ${data.ip_address}:${data.port}\nPassword: ${data.password}\nrDNS: ${data.rdns_hostname}\nScreen: ${data.width}:${data.height}\nComputernewb ID: ${data.id}`, envelope, `${prefix}vnc`, false, Buffer.from(vncimage.data).toString('base64'), vncimage.headers['content-type'], 'jpeg');
            } catch (err) {
                await sendresponse('Failed to get VNC details from API. Please try again later.', envelope, `${prefix}vnc`, true);
            }
        }
    }*/
    /*"blackjack": {
        description: "Play a game of blackjack",
        arguments: ['action', 'gameid', 'wager'],
        execute: async (envelope, message) => {
            const Game = mongoose.model('Game');
            const User = mongoose.model('User');
            const dataMessage = envelope.dataMessage;
            const message = dataMessage.message.trim();
            const args = message.split(' ');
            if (args.length < 2) {
                await sendresponse('Invalid arguments. Use -blackjack [new/hit/stand/start/stop/join/leave/list] [gameid (if applicable)/wager (if creating)] [wager (if joining)]', envelope, `${prefix}blackjack`, true);
                return;
            }
            const action = args[1];
            const gameid = args[2];
            const wager = parseInt(args[3]);
            try {
                const user = await User.findOne({ userid: envelope.sourceUuid });
                if (!user || !user.properties || !user.properties.eco) {
                    await sendresponse('You need a wallet to play. Use -wallet to create one.', envelope, `${prefix}blackjack`, true);
                    return;
                }
                let game;
                if (action === 'new') {
                    if (!gameid || parseInt(gameid) <= 0) {
                        await sendresponse('Please specify a valid wager to start a new game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (user.properties.eco.balance < parseInt(gameid)) {
                        await sendresponse('You do not have enough balance to place this wager.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    user.properties.eco.balance -= parseInt(gameid);
                    user.properties.eco.balance = Math.floor(user.properties.eco.balance);
                    user.markModified('properties');
                    await user.save();
                    game = new Game({
                        hostid: envelope.sourceUuid,
                        players: [{
                            userid: envelope.sourceUuid,
                            hand: [Math.floor(Math.random() * 11) + 1, Math.floor(Math.random() * 11) + 1],
                            wager: parseInt(gameid),
                            stand: false
                        }],
                        dealer: [Math.floor(Math.random() * 11) + 1, Math.floor(Math.random() * 11) + 1],
                        status: 'pending',
                        turn: 0
                    });
                    await game.save();
                    await sendresponse(`New game created with ID: ${game._id}. Wager: E${parseInt(gameid)}. Waiting for players to join. Use -blackjack start ${game._id} to begin.`, envelope, `${prefix}blackjack`, false);
                } else if (action === 'start') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to start.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.hostid !== envelope.sourceUuid) {
                        await sendresponse('You are not the host of this game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.status !== 'pending') {
                        await sendresponse('Game is not in pending state.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game.status = 'active';
                    game.players.push({
                        userid: 'dealer',
                        hand: [],
                        wager: 0,
                        stand: false
                    });
                    game.players.forEach(player => {
                        if (player.userid !== 'dealer') {
                            player.hand = [Math.floor(Math.random() * 11) + 1, Math.floor(Math.random() * 11) + 1];
                        }
                    });
                    game.markModified('players');
                    await game.save();
                    await sendresponse(`Game ${gameid} has started!`, envelope, `${prefix}blackjack`, false);
                    for (const player of game.players) {
                        if (player.userid !== 'dealer') {
                            await sendmessage(`From game ${gameid}:\nYour hand: ${player.hand.join(', ')}`, player.userid, dataMessage.timestamp, phonenumber);
                        }
                    }
                } else if (action === 'stop') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to stop.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.hostid !== envelope.sourceUuid) {
                        await sendresponse('You are not the host of this game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game.status = 'completed';
                    await game.save();
                    await sendresponse(`Game ${gameid} has been stopped.`, envelope, `${prefix}blackjack`, false);
                } else if (action === 'join') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to join.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (!wager || wager <= 0) {
                        await sendresponse('Please specify a valid wager to join the game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.status !== 'pending') {
                        await sendresponse('Game is not in pending state.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.players.find(p => p.userid === envelope.sourceUuid)) {
                        await sendresponse('You are already in this game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (user.properties.eco.balance < wager) {
                        await sendresponse('You do not have enough balance to place this wager.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    user.properties.eco.balance -= wager;
                    user.properties.eco.balance = Math.floor(user.properties.eco.balance);
                    user.markModified('properties');
                    await user.save();
                    game.players.push({
                        userid: envelope.sourceUuid,
                        hand: [Math.floor(Math.random() * 11) + 1, Math.floor(Math.random() * 11) + 1],
                        wager: wager,
                        stand: false
                    });
                    game.markModified('players');
                    await game.save();
                    await sendresponse(`Joined game ${gameid}. Wager: E${wager}. Your hand: ${game.players.find(p => p.userid === envelope.sourceUuid).hand.join(', ')}`, envelope, `${prefix}blackjack`, false);
                } else if (action === 'hit') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to hit.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.status !== 'active') {
                        await sendresponse('Game is not active.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    const pi = game.players.findIndex(p => p.userid === envelope.sourceUuid);
                    if (pi === -1) {
                        await sendresponse('You are not in this game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.properties.turn !== pi) {
                        await sendresponse('It is not your turn.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    const player = game.players[pi];
                    if (player.stand) {
                        await sendresponse('You have already stood.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    player.hand.push(Math.floor(Math.random() * 11) + 1);
                    game.markModified('players');
                    await game.save();
                    const pt = player.hand.reduce((a, b) => a + b, 0);
                    if (pt > 21) {
                        await sendresponse(`You hit. Your new hand: ${player.hand.join(', ')} (Total: ${pt}). You busted!`, envelope, `${prefix}blackjack`, false);
                        player.stand = true;
                        await nextTurn(game, envelope);
                        return;
                    }
                    await sendresponse(`You hit. Your new hand: ${player.hand.join(', ')} (Total: ${pt})`, envelope, `${prefix}blackjack`, false);
                } else if (action === 'stand') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to stand.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.status !== 'active') {
                        await sendresponse('Game is not active.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    const pi = game.players.findIndex(p => p.userid === envelope.sourceUuid);
                    if (pi === -1) {
                        await sendresponse('You are not in this game.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    if (game.properties.turn !== pi) {
                        await sendresponse('It is not your turn.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    const player = game.players[pi];
                    if (player.stand) {
                        await sendresponse('You have already stood.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    player.stand = true;
                    game.markModified('players');
                    await game.save();
                    await sendresponse(`You stand. Your hand: ${player.hand.join(', ')}`, envelope, `${prefix}blackjack`, false);
                    await nextTurn(game, envelope);
                } else if (action === 'leave') {
                    if (!gameid) {
                        await sendresponse('Please specify a game ID to leave.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game = await Game.findById(gameid);
                    if (!game) {
                        await sendresponse('Game not found.', envelope, `${prefix}blackjack`, true);
                        return;
                    }
                    game.players = game.players.filter(p => p.userid !== envelope.sourceUuid);
                    await game.save();
                    await sendresponse(`You have left game ${gameid}.`, envelope, `${prefix}blackjack`, false);
                } else if (action === 'list') {
                    const games = await Game.find({ 'players.userid': envelope.sourceUuid });
                    if (games.length === 0) {
                        await sendresponse('You are not currently in any games.', envelope, `${prefix}blackjack`, false);
                        return;
                    }
                    let gl = 'You are currently in the following games:\n';
                    for (const g of games) {
                        const isHost = g.hostid === envelope.sourceUuid;
                        gl += `- Game ID: ${g._id} (Status: ${g.status}) ${isHost ? '(Host)' : ''}\n`;
                    }
                    await sendresponse(gl.trim(), envelope, `${prefix}blackjack`, false);
                } else {
                    await sendresponse('Invalid action. Use -blackjack [new/hit/stand/start/stop/join/leave/list] [gameid (if applicable)/wager (if creating)] [wager (if joining)]', envelope, `${prefix}blackjack`, true);
                }
            } catch (err) {
                console.error(err);
                await sendresponse('Failed to play blackjack. Please try again later.', envelope, `${prefix}blackjack`, true);
            }
        }
    }*/
/*async function nextTurn(game, envelope) {
    let npi = (game.properties.turn + 1) % game.players.length;
    while (npi !== game.properties.turn) {
        if (game.players[npi].userid !== 'dealer' && !game.players[npi].stand) {
            break;
        }
        npi = (npi + 1) % game.players.length;
    }
    if (npi === game.properties.turn) {
        const di = game.players.findIndex(p => p.userid === 'dealer');
        game.properties.turn = di;
        await dealerTurn(game, envelope);
        return;
    }
    game.properties.turn = npi;
    await game.save();
    const np = game.players[npi];
    await sendresponse(`It is now ${np.userid}'s turn.`, envelope, `${prefix}blackjack`, false);
}

async function dealerTurn(game, envelope) {
    const User = mongoose.model('User');
    const di = game.players.findIndex(p => p.userid === 'dealer');
    const dealer = game.players[di];
    let dealerTotal = dealer.hand.reduce((a, b) => a + b, 0);
    while (dealerTotal < 17) {
        dealer.hand.push(Math.floor(Math.random() * 11) + 1);
        dealerTotal = dealer.hand.reduce((a, b) => a + b, 0);
    }
    await game.save();
    await sendresponse(`Dealer's hand: ${dealer.hand.join(', ')} (Total: ${dealerTotal})`, envelope, `${prefix}blackjack`, false);
    for (const player of game.players) {
        if (player.userid === 'dealer') continue;
        const user = await User.findOne({ userid: player.userid });
        const pt = player.hand.reduce((a, b) => a + b, 0);
        if (pt > 21) {
            await sendresponse(`${player.userid} busted! Dealer wins.`, envelope, `${prefix}blackjack`, false);
        } else if (dealerTotal > 21 || pt > dealerTotal) {
            const winnings = player.wager * 2;
            user.properties.eco.balance += winnings;
            user.markModified('properties');
            await user.save();
            await sendresponse(`${player.userid} wins E${winnings}! New balance: E${user.properties.eco.balance}`, envelope, `${prefix}blackjack`, false);
        } else if (pt === dealerTotal) {
            user.properties.eco.balance += player.wager;
            user.markModified('properties');
            await user.save();
            await sendresponse(`${player.userid} draws! Wager returned. New balance: E${user.properties.eco.balance}`, envelope, `${prefix}blackjack`, false);
        } else {
            await sendresponse(`Dealer wins against ${player.userid}!`, envelope, `${prefix}blackjack`, false);
        }
    }

    game.status = 'completed';
    await game.save();
}*/
    /*"mbexec": {
        description: "Execute a command via Mockingbird (hackmud)",
        arguments: ['command', 'args (optional)'],
        execute: async (envelope, message) => {
            try {
                const dataMessage = envelope.dataMessage;
                const message = dataMessage.message.trim();
                const args = message.split(' ');
                if (args.length < 2) {
                    sendresponse('Invalid arguments.\nUse "-mbexec [command] [args (optional)]" to execute a command via Mockingbird.', envelope, `${prefix}mbexec`, true);
                    return;
                }
                const script = args[1];
                const params = message.slice(message.indexOf(args[1]) + args[1].length).trim() || null;
                const tid = Math.floor(Math.random() * 1024) + 1;
                const id = tid.toString();
                const client = net.connect({ path: './ipc/mockingbird' }, () => {
                    client.write(JSON.stringify({ script, params, id }));
                });
                client.on('data', (data) => {
                    console.log(data.toString());
                    try {
                        const json = JSON.parse(data.toString());
                        console.log(json);
                        if (json.id === id && json.success === false) {
                            sendresponse(`Failed to execute command: ${json.error}`, envelope, `${prefix}mbexec`, true);
                            return;
                        } else if (json.id === id && json.success === true && json.message === 'Script added to queue') {
                            sendresponse(`Command added to queue, please wait...`, envelope);
                        } else if (json.id === id && json.success === true && json.message !== 'Script added to queue') {
                            sendresponse(`${json.message}`, envelope);
                            client.end();
                        }
                    } catch (err) {
                        sendresponse('Failed to parse JSON response.', envelope, `${prefix}mbexec`, true);
                    }
                });
                client.on('error', (err) => {
                    sendresponse(`Failed to execute command: ${err.message}`, envelope, `${prefix}mbexec`, true);
                });
            } catch (err) {
                sendresponse('Somehow this command failed. Please try again later.', envelope, `${prefix}mbexec`, true);
            }
        }
    },*/
                        /*const User = mongoose.model('User');
                        User.findOne({ userid: recipient }).then(searchuser => {
                            if (searchuser) {
                                const properties = searchuser.properties;
                                if (properties && properties.debug && properties.debug === true) {
                                    const msgtimestamp = result.timestamp;
                                    addtimestamp(message, props.isselfcommand ? props.selfcommandsendto : recipient, msgtimestamp, props);
                                }
                            }
                        }).catch(() => {
                            console.error('Error finding user in database for timestamping');
                        });*/
                //quoteTimestamp: quotetimestamp,
                /*if (envelope.sourceName === '' || envelope.sourceName === null || envelope.sourceName === undefined) {
                    console.log(`Received "${message}" from ${envelope.sourceUuid} at ${dataMessage.timestamp}`);
                } else {
                    console.log(`Received "${message}" from ${envelope.sourceUuid} (${envelope.sourceName}) at ${dataMessage.timestamp}`);
                }*/
/*function mockingresponse(message, recipient) {
    persistentconn(() => {
        if (!client || client.destroyed || client.readyState !== 'open') {
            console.error('No handler connection available for mocking response');
            return;
        }
        const tid = Math.floor(Math.random() * 1024) + 1;
        const id = tid.toString();
        let json = {
            jsonrpc: '2.0',
            id,
            method: 'send',
            params: {
                account: phonenumber,
                recipient: `${recipient}`,
                message,
                textStyle: `0:${message.length}:MONOSPACE`,
            },
        };
        json = JSON.stringify(json);
        client.write(json + '\n');
        const responsehandler = (data) => {
            const content = data.toString();
            if (content == null || content === '' || content === undefined || content === '\n') {
                return;
            }
            try {
                const pj = JSON.parse(content);
                if (pj.id === id) {
                    client.removeListener('data', responsehandler);
                    if (pj.error) {
                        console.error('Error sending message:', pj.error);
                        return;
                    }
                    const result = pj.result;
                    const results = result.results;
                    if (results[0].type === 'SUCCESS') {
                        return;
                    }
                }
            } catch (error) {
                return;
            }
        };
        client.on('data', responsehandler);
        setTimeout(() => {
            client.removeListener('data', responsehandler);
        }, 5000);
    });
};*/
    /*let timestamp;
    if (dataMessage && dataMessage.timestamp) {
        timestamp = dataMessage.timestamp;
    } else if (sentMessage && sentMessage.timestamp) {
        timestamp = sentMessage.timestamp;
    } else {
        timestamp = null;
    }*/
    //mockingresponse,
/*import net from 'net';
import fs from 'fs';
import { mockingresponse } from './signalhandler.js';

function mockingbirdsocket() {
    const ipcServer = net.createServer((socket) => {
        socket.on('data', (data) => {
            data = data.toString();
            if (typeof data === 'string') {
                data = JSON.parse(data);
            }
            if (data.type === 'chatstells') {
                mockingresponse('chats.tell to ' + data.curruser + ' from ' + data.user + ': ' + data.msg, '365b3040-dace-48b8-94f6-7b61c8808096');
            } else if (data.type === 'scorpio') {
                mockingresponse(data.msg, '365b3040-dace-48b8-94f6-7b61c8808096');
            }
        });
    });

    if (fs.existsSync('./ipc/tritiumbotv2')) {
        fs.unlinkSync('./ipc/tritiumbotv2');
    }

    ipcServer.listen('./ipc/tritiumbotv2');
};

export { mockingbirdsocket };*/
        /*client.on('data', (data) => {
            const content = data.toString();
            if (content == null || content === '' || content === undefined || content === '\n') {
                return;
            } else {
                try {
                    const pj = JSON.parse(content);
                    if (pj.id === id) {
                        if (pj.error) {
                            console.error('Error sending profile data:', pj.error, pj.error.data.response.results);
                            return;
                        }
                        const result = pj.result;
                        const results = result.results;
                        if (results === undefined) {
                            client.end();
                            return;
                        }
                    } else {
                        client.end();
                        return;
                    }
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                }
            };
        });
        setTimeout(() => {
            if (!client.destroyed) {
                client.end();
            }
        }, 5000);*/
    //mockingbirdsocket();
/*function addtimestamp(message, recipient, timestamp, props={}) {
    persistentconn(() => {
        if (!client || client.destroyed || client.readyState !== 'open') {
            console.error('No handler connection available for adding timestamp');
            return;
        }
        const tid = Math.floor(Math.random() * 1024) + 1;
        const id = tid.toString();
        let json = {
            jsonrpc: '2.0',
            id,
            method: 'send',
            params: {
                account: phonenumber,
                recipient: `${recipient}`,
                editTimestamp: timestamp,
            },
        };
        if (props.groupid) {
            json.params.groupId = `${props.groupid}`;
        }
        if (message) {
            json.params.message = `${message}\n\nMessage timestamp: ${timestamp}`
            if (message.includes('$MENTIONUSER')) {
                const startofmention = message.indexOf('$MENTIONUSER');
                json.params.mention = `${startofmention}:${"$MENTIONUSER".length}:${recipient}`
            }
        } else {
            json.params.message = `Message timestamp: ${timestamp}`;
        }
        if (props.image) {
            json.params.attachments = [`data:${props.mime};filename=file.${props.imageext};base64,${props.image}`];
        }
        if (props.file) {
            json.params.attachments = [`./${props.file}`];
        }
        json = JSON.stringify(json);
        client.write(json + '\n');
        const responsehandler = (data) => {
            const content = data.toString();
            if (content == null || content === '' || content === undefined || content === '\n') {
                return;
            }
            try {
                const pj = JSON.parse(content);
                if (pj.id === id) {
                    client.removeListener('data', responsehandler);
                    if (pj.error) {
                        console.error('Error editing message:', pj.error);
                        return;
                    }
                    const result = pj.result;
                    const results = result.results;
                    if (results[0].type === 'SUCCESS') {
                        return;
                    } else {
                        console.error('Error sending message:', results[0].type);
                        return;
                    }
                }
            } catch (error) {
                return;
            }
        };
        client.on('data', responsehandler);
        setTimeout(() => {
            client.removeListener('data', responsehandler);
        }, 5000);
    });
};*/
                //quoteTimestamp: timestamp,